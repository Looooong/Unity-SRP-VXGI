#pragma kernel CSAggregate D3D11
#pragma kernel CSAggregate
#pragma kernel CSClear
#pragma kernel CSRender
#pragma kernel CSRender VXGI_CASCADES
#pragma enable_d3d11_debug_symbols

#include "Packages/com.looooong.srp.vxgi/ShaderLibrary/Structs/VoxelData.cginc"
#include "Packages/com.looooong.srp.vxgi/ShaderLibrary/Structs/VoxelLightingData.hlsl"
#include "Packages/com.looooong.srp.vxgi/ShaderLibrary/Radiances/Voxel.cginc"

#define RADIANCE_PRECISION 256.0

RWTexture3D<uint> RadianceRG;
RWTexture3D<uint> RadianceBA;
RWTexture3D<uint> RadianceCount;
RWTexture3D<float4> Target;
ConsumeStructuredBuffer<VoxelData> VoxelBuffer;

[numthreads(4,4,4)]
void CSAggregate(uint3 id : SV_DispatchThreadID)
{
  // if (any(id >= Resolution)) return;

  uint rg = RadianceRG[id];
  uint ba = RadianceBA[id];
  uint count = RadianceCount[id];

  if (count > 0u) {
    float4 color = uint4(
      rg & 0xffff,
      rg >> 16u,
      ba & 0xffff,
      ba >> 16u
    ) / RADIANCE_PRECISION;

    Target[id] = color / count;
  } else {
#ifdef D3D11
    // Write only when necessary
    if (any(Target[id])) Target[id] = 0.0;
#else
    Target[id] = 0.0;
#endif
  }
}

[numthreads(4,4,4)]
void CSClear(uint3 id : SV_DispatchThreadID)
{
  // if (any(id >= Resolution)) return;

  // Target[id] = 0.0;

  RadianceRG[id] = 0u;
  RadianceBA[id] = 0u;
  RadianceCount[id] = 0u;
}

[numthreads(64,1,1)]
void CSRender(uint id : SV_DispatchThreadID)
{
  VoxelData data = VoxelBuffer.Consume();

  DeviceMemoryBarrierWithGroupSync();

  if (!data.IsValid()) return;

  float3 position = data.GetPosition();
  float3 normal = data.GetNormal();
  float4 color = data.GetColor();
  float3 emission = data.GetEmission();

#ifdef VXGI_CASCADES
  color = float4(mad(normal, 0.5, 0.5), 1.0);
#else
  position *= Resolution;

  VoxelLightingData lightingData;
  lightingData.color = color.rgb;
  lightingData.voxelPosition = position;
  lightingData.vecN = normal;
  lightingData.Initialize();

  color.rgb = emission + VoxelRadiance(lightingData);
  color.a = saturate(color.a);
#endif

  uint4 intColor = (uint4)round(color * RADIANCE_PRECISION);
  uint rg = intColor.r | intColor.g << 16;
  uint ba = intColor.b | intColor.a << 16;

#ifdef VXGI_CASCADES
  for (int level = MinSampleLevel(position); level < VXGI_CascadesCount; level++) {
    float3 uvw = mad(
      position,
      exp2(VXGI_CascadesCountMinusOne - level),
      0.5 - exp2(VXGI_CascadesCountMinusOne - level - 1)
    );
    uvw = min(Resolution * uvw, Resolution - 0.000001);
    uvw.z += level * Resolution;

    [allow_uav_condition]
    for (
      int i = 0, count = RadianceCount[uvw], originalCount = -1;
      i < 16 && count < 16;
      i++, count = originalCount
    ) {
      InterlockedCompareExchange(RadianceCount[uvw], count, count + 1, originalCount);

      if (count == originalCount)
      {
        InterlockedAdd(RadianceRG[uvw], rg);
        InterlockedAdd(RadianceBA[uvw], ba);
        break;
      }
    }
  }
#else
  position = min(position, Resolution - 0.000001);

  InterlockedAdd(RadianceRG[position], rg);
  InterlockedAdd(RadianceBA[position], ba);
  InterlockedAdd(RadianceCount[position], 1);
#endif
}
