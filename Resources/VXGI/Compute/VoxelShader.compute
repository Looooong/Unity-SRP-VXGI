#pragma kernel CSAggregate
#pragma kernel CSAggregate D3D11
#pragma kernel CSAggregate VXGI_CASCADES
#pragma kernel CSAggregate D3D11 VXGI_CASCADES
#pragma kernel CSClear
#pragma kernel CSClear VXGI_CASCADES
#pragma kernel CSRender
#pragma kernel CSRender VXGI_CASCADES

#include "Packages/com.looooong.srp.vxgi/ShaderLibrary/Structs/VoxelData.cginc"
#include "Packages/com.looooong.srp.vxgi/ShaderLibrary/Structs/VoxelLightingData.hlsl"
#include "Packages/com.looooong.srp.vxgi/ShaderLibrary/Radiances/Voxel.cginc"

#define RADIANCE_PRECISION 256.0

groupshared uint VXGI_VoxelFragmentsCount;
RWByteAddressBuffer VXGI_VoxelFragmentsCountBuffer;

RWTexture3D<uint> RadianceRG;
RWTexture3D<uint> RadianceBA;
RWTexture3D<uint> RadianceCount;
RWTexture3D<float4> Target;
ConsumeStructuredBuffer<VoxelData> VoxelBuffer;

[numthreads(4,4,4)]
void CSAggregate(uint3 id : SV_DispatchThreadID)
{
  if (any(id >= VXGI_TexelResolution)) return;

  uint rg = RadianceRG[id];
  uint ba = RadianceBA[id];
  uint count = RadianceCount[id];

  if (count > 0u) {
    float4 color = uint4(
      rg & 0xffff,
      rg >> 16u,
      ba & 0xffff,
      ba >> 16u
    ) / RADIANCE_PRECISION;

    Target[id] = color / count;
  } else {
#ifdef D3D11
    // Write only when necessary
    if (any(Target[id])) Target[id] = 0.0;
#else
    Target[id] = 0.0;
#endif
  }
}

[numthreads(4,4,4)]
void CSClear(uint3 id : SV_DispatchThreadID)
{
  if (any(id >= VXGI_TexelResolution)) return;

  RadianceRG[id] = 0u;
  RadianceBA[id] = 0u;
  RadianceCount[id] = 0u;
}

[numthreads(64,1,1)]
void CSRender(uint id : SV_DispatchThreadID, uint gtid : SV_GroupThreadId)
{
  if (gtid == 0) VXGI_VoxelFragmentsCount = VXGI_VoxelFragmentsCountBuffer.Load(0);

  GroupMemoryBarrierWithGroupSync();

  if (id >= VXGI_VoxelFragmentsCount) return;

  VoxelData data = VoxelBuffer.Consume();

  float3 position = data.GetPosition();
  float3 normal = data.GetNormal();
  float4 color = data.GetColor();
  float3 emission = data.GetEmission();

#ifdef VXGI_CASCADES
  uint level = data.GetCascadeIndex();

  position = TransformCascadeToVoxelPosition(position, level);
#else
  position *= Resolution;
#endif

  VoxelLightingData lightingData;
  lightingData.color = color.rgb;
  lightingData.voxelPosition = position;
  lightingData.vecN = normal;
  lightingData.Initialize();

  color.rgb = emission + VoxelRadiance(lightingData);
  color.a = saturate(color.a);

  uint4 intColor = (uint4)round(color * RADIANCE_PRECISION);
  uint rg = intColor.r | intColor.g << 16;
  uint ba = intColor.b | intColor.a << 16;

#ifdef VXGI_CASCADES
  float3 uvw = TransformVoxelToTexelPosition(position, level);
  uvw = min(VXGI_TexelResolution * uvw, VXGI_TexelResolutionMinus);

  InterlockedAdd(RadianceRG[uvw], rg);
  InterlockedAdd(RadianceBA[uvw], ba);
  InterlockedAdd(RadianceCount[uvw], 1);
#else
  position = min(position, Resolution - 0.000001);

  InterlockedAdd(RadianceRG[position], rg);
  InterlockedAdd(RadianceBA[position], ba);
  InterlockedAdd(RadianceCount[position], 1);
#endif
}
