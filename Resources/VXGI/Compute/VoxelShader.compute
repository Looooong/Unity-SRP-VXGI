#pragma kernel CSRender
#pragma kernel CSRender VXGI_CASCADES
#pragma kernel CSRender VXGI_ANISOTROPIC_VOXEL
#pragma kernel CSRender VXGI_CASCADES VXGI_ANISOTROPIC_VOXEL

#include "Packages/com.looooong.srp.vxgi/ShaderLibrary/Structs/VoxelData.cginc"
#include "Packages/com.looooong.srp.vxgi/ShaderLibrary/Structs/VoxelLightingData.hlsl"
#include "Packages/com.looooong.srp.vxgi/ShaderLibrary/Radiances/Voxel.cginc"

RWTexture3D<float4> Target;
RWStructuredBuffer<VoxelData> VoxelBuffer;
RWTexture3D<int> FragmentPointers;

#ifdef VXGI_CASCADES
static uint3 VXGI_TexelResolution = uint3(Resolution, Resolution, Resolution * VXGI_CascadesCount);
#else
static uint3 VXGI_TexelResolution = Resolution;
#endif

static float3 VXGI_DoubleTexelResolution = 2.0 * VXGI_TexelResolution;
static float3 VXGI_DoubleTexelResolutionMinus = 2.0 * VXGI_TexelResolution - 0.000001;
static float3 VXGI_TexelResolutionMinus = VXGI_TexelResolution - 0.000001;

#define LOOP_LIMIT 100
#define KEEPALPHA(x) float4((x).rgb, LitColor.a)
//#define KEEPALPHA(x) x

[numthreads(4,4,4)]
void CSRender(uint3 id : SV_DispatchThreadID)
{
  uint pointer = FragmentPointers[id];
  if (pointer!=0)
    FragmentPointers[id] = 0;//Really important! This is how the pointer volume is cleared.

  float count = 0;
#ifdef VXGI_ANISOTROPIC_VOXEL
  float4 finalColors[6];
  [unroll]
  for (uint side = 0u; side < 6u; side++) {
    finalColors[side] = float4(0, 0, 0, 0);
  }

  while (pointer != 0 && count < LOOP_LIMIT)
  {
    VoxelData data = VoxelBuffer[pointer];

    float3 normal = data.GetNormal();
    float4 LitColor = data.GetColor();

    finalColors[0] += KEEPALPHA(LitColor * saturate(normal.x));
    finalColors[1] += KEEPALPHA(LitColor * saturate(normal.x * -1));
    finalColors[2] += KEEPALPHA(LitColor * saturate(normal.y));
    finalColors[3] += KEEPALPHA(LitColor * saturate(normal.y * -1));
    finalColors[4] += KEEPALPHA(LitColor * saturate(normal.z));
    finalColors[5] += KEEPALPHA(LitColor * saturate(normal.z * -1));
    count += 1;

    pointer = data.GetPointer();
  }

  float4 invcount = float4(float(3.1415).xxx, 1) / max(1, count);

  [unroll]
  for (uint side = 0u; side < 6u; side++) {
    float4 finalColor = finalColors[side];

    uint3 uvw = uint3(id.x, mad(Resolution, side, id.y), id.z);

    finalColor *= invcount;

    Target[uvw] = finalColor;
  }
#else //VXGI_ANISOTROPIC_VOXEL
  float4 finalColor = float4(0, 0, 0, 0);

  while (pointer != 0 && count < LOOP_LIMIT)
  {
    VoxelData data = VoxelBuffer[pointer];

    finalColor += data.GetColor();
    count += 1;

    pointer = data.GetPointer();
  }

  finalColor /= max(1, count);

  Target[id] = finalColor;
#endif
}
